<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基础知识 | Frontend Knowledge Base</title>
    <meta name="description" content="hello">
    <link rel="icon" href="/Frontend-Knowledge-Base/knowledge-base.png">
  <link rel="manifest" href="/Frontend-Knowledge-Base/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="msapplication-TileColor" content="#000000">
    <meta name="keywords" content="super duper SEO">
    <link rel="preload" href="/Frontend-Knowledge-Base/assets/css/0.styles.512f36c0.css" as="style"><link rel="preload" href="/Frontend-Knowledge-Base/assets/js/app.be30c89b.js" as="script"><link rel="preload" href="/Frontend-Knowledge-Base/assets/js/4.d5d74749.js" as="script"><link rel="preload" href="/Frontend-Knowledge-Base/assets/js/40.ee0861ee.js" as="script"><link rel="preload" href="/Frontend-Knowledge-Base/assets/js/9.1a9c75bd.js" as="script"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/10.14beec70.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/11.1baa7ffd.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/12.b25e3f14.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/13.5e243a3b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/14.8c43e0ed.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/15.8b7ce3ce.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/16.8ab4ae66.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/17.fe99a1e3.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/18.3313bd50.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/19.de937db9.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/20.1836cb3d.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/21.65652483.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/22.fb27e07b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/23.47c1ae4c.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/24.232a53b1.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/25.c6a72e25.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/26.0a0a2701.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/27.0fdc9a1a.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/28.e889eaeb.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/29.46bd6339.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/30.7fef7b22.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/31.6d22a163.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/32.91863d2b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/33.38e661a7.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/34.95d36277.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/35.4dcca28e.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/36.eff9b2db.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/37.83295d49.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/38.9dc5afb4.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/39.8d439768.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/41.88810310.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/42.fc9b11e7.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/43.6c927e3a.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/44.f886a111.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/45.80ab5dac.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/46.3e9e3e75.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/47.0eda127c.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/48.44c82d8d.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/49.4607fb6a.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/5.2bf069a5.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/50.9f0623b6.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/51.f796f30a.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/52.14bba200.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/53.ffdc0ead.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/54.0a659db0.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/55.5742c9fa.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/56.65596741.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/57.307a563b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/58.fae9ed04.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/59.aa64338b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/6.90c6bd27.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/60.8ed25f8b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/61.f7b0fdbd.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/62.8a215a5b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/63.60ac3ff9.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/64.df85119c.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/65.f263abd9.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/66.c9dc87d6.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/67.6152f8ea.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/68.f8f9f63b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/69.236ffdcc.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/7.567f554d.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/70.a508e7e0.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/71.a7032d11.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/72.a6250581.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/73.1a604c5b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/74.fa6d0d2d.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/75.2839c2d3.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/76.786f0d39.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/77.6a25f56b.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/78.776f55f5.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/79.b69d3416.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/8.23699700.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/80.8a98d0eb.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/81.d9a21bed.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/82.6ac5eff6.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/83.f2c7eacb.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/click-prefetch.507fe4e7.js"><link rel="prefetch" href="/Frontend-Knowledge-Base/assets/js/vendors~docsearch.1829cd5d.js">
    <link rel="stylesheet" href="/Frontend-Knowledge-Base/assets/css/0.styles.512f36c0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Frontend-Knowledge-Base/" class="home-link router-link-active"><!----> <span class="site-name">Frontend Knowledge Base</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/" class="nav-link router-link-exact-active router-link-active">前端</a></div><div class="nav-item"><a href="/Frontend-Knowledge-Base/cs/linux/linux.html" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/Frontend-Knowledge-Base/book/" class="nav-link">书籍</a></div><div class="nav-item"><a href="/Frontend-Knowledge-Base/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="https://jinjun.wiki/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/jinjun1994/Frontend-Knowledge-Base" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/" class="nav-link router-link-exact-active router-link-active">前端</a></div><div class="nav-item"><a href="/Frontend-Knowledge-Base/cs/linux/linux.html" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/Frontend-Knowledge-Base/book/" class="nav-link">书籍</a></div><div class="nav-item"><a href="/Frontend-Knowledge-Base/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="https://jinjun.wiki/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/jinjun1994/Frontend-Knowledge-Base" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/" class="active sidebar-link">基础知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#类型" class="sidebar-link">类型</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#类型判断" class="sidebar-link">类型判断</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#typeof" class="sidebar-link">typeof</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#instanceof" class="sidebar-link">instanceof</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#object-prototype-tostring" class="sidebar-link">Object.prototype.toString</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#symbol-tostringtag" class="sidebar-link">Symbol.toStringTag</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#总结" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#类型转换" class="sidebar-link">类型转换</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#toboolean" class="sidebar-link">ToBoolean</a></li></ul></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#运行机制" class="sidebar-link">运行机制</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#数据类型" class="sidebar-link">数据类型</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#函数" class="sidebar-link">函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#隐式函数参数" class="sidebar-link">隐式函数参数</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#函数调用与this" class="sidebar-link">函数调用与this</a></li></ul></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#深浅拷贝" class="sidebar-link">深浅拷贝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#浅拷贝" class="sidebar-link">浅拷贝</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#深拷贝" class="sidebar-link">深拷贝</a></li></ul></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#开发者工具devtools" class="sidebar-link">开发者工具devtools</a></li><li class="sidebar-sub-header"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/#编程思想" class="sidebar-link">编程思想</a></li></ul></li><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/array.html" class="sidebar-link">数组</a></li><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/object.html" class="sidebar-link">对象、类和继承</a></li><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/dom.html" class="sidebar-link">DOM</a></li><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/closure.html" class="sidebar-link">闭包的前世今生</a></li><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/async.html" class="sidebar-link">异步编程全传</a></li><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/promise.html" class="sidebar-link">手写promise</a></li><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/event.html" class="sidebar-link">事件</a></li><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/es6.html" class="sidebar-link">/frontend/JavaScript/es6.html</a></li><li><a href="/Frontend-Knowledge-Base/frontend/JavaScript/es7-10.html" class="sidebar-link">/frontend/JavaScript/es7-10.html</a></li></ul></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>html</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端图形学</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable"><p class="sidebar-heading"><span>微信小程序</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="back-to-ceiling" style="right:1rem;bottom:3rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;background-color:rgba(231, 234, 241,.5);display:none;" data-v-7efdea1b data-v-7efdea1b><i class="iconfont icon-rocket" data-v-7efdea1b></i></div> <main class="page"> <div class="page-none"></div> <div class="page-title"><h1>基础知识</h1> <hr> <div class="pageInfo" data-v-3a11415e><i class="icon-author iconfont" data-v-3a11415e><span data-v-3a11415e>jinjun</span></i> <i class="icon-time iconfont" data-v-3a11415e><span data-v-3a11415e>2019/2/10</span></i> <span id="/frontend/JavaScript/" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-ea098484 data-v-3a11415e><i class="icon-eye" style="font-size:.9rem;font-weight:normal;color:#999;" data-v-ea098484></i> <a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;" data-v-ea098484></a></span></div></div> <div class="content default"><p></p><div class="table-of-contents"><ul><li><a href="#类型">类型</a></li><li><a href="#类型判断">类型判断</a><ul><li><a href="#typeof">typeof</a></li><li><a href="#instanceof">instanceof</a></li><li><a href="#object-prototype-tostring">Object.prototype.toString</a></li><li><a href="#symbol-tostringtag">Symbol.toStringTag</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#类型转换">类型转换</a><ul><li><a href="#toboolean">ToBoolean</a></li></ul></li><li><a href="#运行机制">运行机制</a></li><li><a href="#数据类型">数据类型</a></li><li><a href="#函数">函数</a><ul><li><a href="#隐式函数参数">隐式函数参数</a></li><li><a href="#函数调用与this">函数调用与this</a></li></ul></li><li><a href="#深浅拷贝">深浅拷贝</a><ul><li><a href="#浅拷贝">浅拷贝</a></li><li><a href="#深拷贝">深拷贝</a></li></ul></li><li><a href="#开发者工具devtools">开发者工具devtools</a></li><li><a href="#编程思想">编程思想</a></li></ul></div><p></p> <h2 id="类型"><a href="#类型" aria-hidden="true" class="header-anchor">#</a> 类型</h2> <p>JavaScript 中有八种基本的类型。</p> <ul><li><code>number</code> 用于任何类型的数字：整数或者浮点数。</li> <li><code>string</code> 用于字符串。一个字符串可以包含一个或多个字符，所以没有单独的单字符类型。</li> <li><code>boolean</code> 用于 <code>true</code> 和 <code>false</code>。</li> <li><code>null</code> 用于未知的值 —— 只有一个 <code>null</code> 值的独立类型。</li> <li><code>undefined</code> 用于未定义的值 —— 只有一个 <code>undefined</code> 值的独立类型。</li> <li><code>object</code> 用于更复杂的数据结构。</li> <li><code>symbol</code> 用于唯一的标识符。</li> <li><code>bigint</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener noreferrer">没有精度和大小限制的整数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="类型判断"><a href="#类型判断" aria-hidden="true" class="header-anchor">#</a> 类型判断</h2> <h3 id="typeof"><a href="#typeof" aria-hidden="true" class="header-anchor">#</a> typeof</h3> <p><code>typeof</code> 运算符可以查看变量的类型。</p> <ul><li>两种形式：<code>typeof x</code> 或者 <code>typeof(x)</code>。</li> <li>返回的类型的字符串，比如 <code>&quot;string&quot;</code>。</li> <li><code>null</code> 返回 <code>&quot;object&quot;</code> —— 这是语言中的一个错误，实际上它并不是一个对象。</li></ul> <p><code>typeof</code> 对于基本类型，除了 <code>null</code> 都可以显示正确的类型</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment">// 'number'</span>
<span class="token keyword">typeof</span> <span class="token string">'1'</span> <span class="token comment">// 'string'</span>
<span class="token keyword">typeof</span> <span class="token number">999999999999999</span>n <span class="token comment">// 'bigint'</span>
<span class="token keyword">typeof</span> undefined <span class="token comment">// 'undefined'</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment">// 'boolean'</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'symbol'</span>
<span class="token keyword">typeof</span> b <span class="token comment">// b 没有声明，但是还会显示 undefined</span>
<span class="token keyword">typeof</span><span class="token template-string"><span class="token string">` 对于对象，除了函数都会显示 `</span></span>object
<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log <span class="token comment">// 'function'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="instanceof"><a href="#instanceof" aria-hidden="true" class="header-anchor">#</a> instanceof</h3> <p><code>instanceof</code> 操作符用于检测对象是否属于某个 class，同时，检测过程中也会将继承关系考虑在内。</p> <p>用法：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>obj <span class="token keyword">instanceof</span> <span class="token class-name">Class</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果 <code>obj</code> 隶属于 <code>Class</code> 类（或者是 <code>Class</code> 类的衍生类），表达式将返回 <code>true</code>。</p> <p>举例说明：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Rabbit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// rabbit 是 Rabbit 类的实例对象吗?</span>
<span class="token function">alert</span><span class="token punctuation">(</span> rabbit <span class="token keyword">instanceof</span> <span class="token class-name">Rabbit</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>使用构造函数结果也是一样的：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 构造函数而非 class</span>
<span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Rabbit</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>内置类型 <code>Array</code>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>arr</code> 同时还隶属于 <code>Object</code> 类。因为从原型上来讲，<code>Array</code> 是继承自 <code>Object</code> 类的。</p> <p><code>instanceof</code> 在检测中会将原型链考虑在内，此外，还能借助静态方法 <code>Symbol.hasInstance</code> 来改善检测效果。</p> <p><code>obj instanceof Class</code> 语句的大致执行过程如下：</p> <ol><li><p>如果提供了静态方法 <code>Symbol.hasInstance</code>，那就直接用这个方法进行检测：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 假设具有 canEat 属性的对象为动物类</span>
<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>canEat<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> canEat<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 true：调用 Animal[Symbol.hasInstance](obj)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>大部分的类是没有 <code>Symbol.hasInstance</code> 方法的，这时会检查 <code>Class.prototype</code> 是否与 <code>obj</code> 的原型链中的任何一个原型相等。</p> <p>简而言之，是这么比较的：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Class<span class="token punctuation">.</span>prototype
obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Class<span class="token punctuation">.</span>prototype
obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Class<span class="token punctuation">.</span>prototype
<span class="token operator">...</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在上一个例子中有 <code>Rabbit.prototype === rabbit.__proto__</code> 成立，所以结果是显然的。</p> <p>再比如下面一个继承的例子，<code>rabbit</code> 对象同时也是父类的一个实例：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Rabbit</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>rabbit <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// rabbit.__proto__ === Rabbit.prototype</span>
<span class="token comment">// rabbit.__proto__.__proto__ === Animal.prototype (match!)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ol> <p>下图展示了 <code>rabbit instanceof Animal</code> 的执行过程中，<code>Animal.prototype</code> 是如何参与比较的：</p> <p><img src="https://img.amazingtm.com/201903/07113616.png" alt=""></p> <p>这里还要提到一个方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf" target="_blank" rel="noopener noreferrer">objA.isPrototypeOf(objB)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，如果 <code>objA</code> 处在 <code>objB</code> 的原型链中，调用结果为 <code>true</code>。所以，<code>obj instanceof Class</code> 也可以被视作为是调用 <code>Class.prototype.isPrototypeOf(obj)</code>。</p> <p>虽然有点奇葩，其实 <code>Class</code> 的构造器自身是不参与检测的！检测过程只和原型链以及 <code>Class.prototype</code> 有关。</p> <p>所以，当 <code>prototype</code> 改变时，会产生意想不到的结果。</p> <p>就像这样：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 修改其 prototype</span>
Rabbit<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// ...再也不是只兔子了！</span>
<span class="token function">alert</span><span class="token punctuation">(</span> rabbit <span class="token keyword">instanceof</span> <span class="token class-name">Rabbit</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>所以，为了谨慎起见，最好避免修改 <code>prototype</code>。</p> <h3 id="object-prototype-tostring"><a href="#object-prototype-tostring" aria-hidden="true" class="header-anchor">#</a> Object.prototype.toString</h3> <p>按照 <a href="https://tc39.github.io/ecma262/#sec-object.prototype.tostring" target="_blank" rel="noopener noreferrer">规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 上所讲，内置的 <code>toString</code> 方法可以从对象中提取出来，以其他值作为上下文（context）对象进行调用，调用结果取决于传入的上下文对象。</p> <ul><li>如果传入的是 number 类型，返回 <code>[object Number]</code></li> <li>如果传入的是 boolean 类型，返回 <code>[object Boolean]</code></li> <li>如果传入 <code>null</code>，返回 <code>[object Null]</code></li> <li>传入 <code>undefined</code>，返回 <code>[object Undefined]</code></li> <li>传入数组，返回 <code>[object Array]</code></li> <li>…等等（例如一些自定义类型）</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> s <span class="token operator">=</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">;</span>
<span class="token comment">// toString 的内部算法会检查 this 对象，返回对应的结果。</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Number]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Null]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Function]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">123</span>n<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object BigInt]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Array]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Object]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Boolean]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Symbol]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="symbol-tostringtag"><a href="#symbol-tostringtag" aria-hidden="true" class="header-anchor">#</a> Symbol.toStringTag</h3> <p>对象的 <code>toString</code> 方法可以使用 <code>Symbol.toStringTag</code> 这个特殊的对象属性进行自定义输出。</p> <p>举例说明：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toStringTag<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">&quot;User&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object User]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>大部分和环境相关的对象也有这个属性。以下输出可能因浏览器不同而异：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 环境相关对象和类的 toStringTag：</span>
<span class="token function">alert</span><span class="token punctuation">(</span> window<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toStringTag<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>
<span class="token function">alert</span><span class="token punctuation">(</span> XMLHttpRequest<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toStringTag<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// XMLHttpRequest</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Window]</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object XMLHttpRequest]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>输出结果和 <code>Symbol.toStringTag</code>（前提是这个属性存在）一样，只不过被包裹进了 <code>[object ...]</code> 里。</p> <p>这样一来，我们手头上就有了个“磕了药似的 typeof”，不仅能检测基本数据类型，就是内置对象类型也不在话下，更可贵的是还支持自定义。</p> <p>所以，如果希望以字符串的形式获取内置对象类型信息，而不仅仅只是检测类型的话，可以用这个方法来替代 <code>instanceof</code>。</p> <h3 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h3> <p>下面，来总结下大家学到的类型检测方式：</p> <table><thead><tr><th></th> <th>用于</th> <th>返回</th></tr></thead> <tbody><tr><td><code>typeof</code></td> <td>基本数据类型</td> <td>string</td></tr> <tr><td><code>{}.toString</code></td> <td>基本数据类型、内置对象以及包含 <code>Symbol.toStringTag</code> 属性的对象</td> <td>string</td></tr> <tr><td><code>instanceof</code></td> <td>任意对象</td> <td>true/false</td></tr></tbody></table> <p>看样子，<code>{}.toString</code> 基本就是一增强版 <code>typeof</code>。</p> <p><code>instanceof</code> 在涉及多层类结构的场合中比较实用，这种情况下需要将类的继承关系考虑在内。</p> <h2 id="类型转换"><a href="#类型转换" aria-hidden="true" class="header-anchor">#</a> 类型转换</h2> <h3 id="toboolean"><a href="#toboolean" aria-hidden="true" class="header-anchor">#</a> ToBoolean</h3> <p>转换为 boolean 类型是最为简单的一个。</p> <p>逻辑操作或显式调用 <code>Boolean(value)</code> 会触发 boolean 类型转换。</p> <p>转换规则如下：</p> <ul><li>假值，JavaScript只有六个假值 <code>0</code>、空的字符串、<code>null</code>、<code>undefined</code> 和 <code>NaN</code>、 <code>false</code>。</li> <li>其他值变成 <code>true</code>。</li></ul> <p>注意：0 包括 0 、+0、 -0、0n、-0n</p> <p><a href="https://juejin.im/post/5c7c8e125188256365101c34#heading-19" target="_blank" rel="noopener noreferrer">ES10<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="运行机制"><a href="#运行机制" aria-hidden="true" class="header-anchor">#</a> 运行机制</h2> <p>生命周期</p> <p>页面构建过程</p> <p>事件处理</p> <h2 id="数据类型"><a href="#数据类型" aria-hidden="true" class="header-anchor">#</a> 数据类型</h2> <p>数组</p> <p>对象</p> <h2 id="函数"><a href="#函数" aria-hidden="true" class="header-anchor">#</a> 函数</h2> <p>函数定义、参数</p> <h3 id="隐式函数参数"><a href="#隐式函数参数" aria-hidden="true" class="header-anchor">#</a> 隐式函数参数</h3> <p>函数调用时还会传递两个隐式的参数：arguments和this。</p> <p>arguments参数是传递给函数的所有参数集合。无论是否有明确定义对应的形参，通过它我们都可以访问到函数的所有参数。</p> <p>当调用函数时，除了显式提供的参数外，this参数也会默认地传递给函数。this参数是面向对象JavaScript编程的一个重要组成部分，代表函数调用相关联的对象。因此，通常称之为函数上下文。</p> <h3 id="函数调用与this"><a href="#函数调用与this" aria-hidden="true" class="header-anchor">#</a> 函数调用与this</h3> <p>函数的调用方式对函数内代码的执行有很大的影响，主要体现在this参数以及函数上下文是如何建立的。</p> <p>我们可以通过4种方式调用一个函数，每种方式之间有一些细微差别。</p> <ul><li>作为一个函数(function)——skulk()，直接被调用。</li> <li>作为一个方法(method)——ninja.skulk()，关联在一个对象上，实现面向对象编程。</li> <li>作为一个构造函数(constructor)——new Ninja()，实例化一个新的对象。</li> <li>通过函数的apply或者call方法——skulk.apply(ninja)或者skulk.call(ninja)。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">skulk</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Ninja</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token function">skulk</span><span class="token punctuation">(</span><span class="token string">'Hattori'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>who<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> who<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'Hattori'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 　　←<span class="token operator">--</span><span class="token operator">-</span>　作为函数调用

<span class="token keyword">var</span> ninja <span class="token operator">=</span> <span class="token punctuation">{</span>
　skulk<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

ninja<span class="token punctuation">.</span><span class="token function">skulk</span><span class="token punctuation">(</span><span class="token string">'Hattori'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 　　←<span class="token operator">--</span><span class="token operator">-</span>　作为ninja对象的一个方法调用

ninja <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ninja</span><span class="token punctuation">(</span><span class="token string">'Hattori'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 　　←<span class="token operator">--</span><span class="token operator">-</span>　作为构造函数调用

skulk<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ninja<span class="token punctuation">,</span> <span class="token string">'Hattori'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 　　←<span class="token operator">--</span><span class="token operator">-</span>　通过call方法调用

skulk<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>ninja<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Hattori'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 　　←<span class="token operator">--</span><span class="token operator">-</span>　通过apply方法调用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>除了call和apply的方式外，函数调用的操作符都是函数表达式之后加一对圆括号。</p> <h4 id="作为函数直接被调用"><a href="#作为函数直接被调用" aria-hidden="true" class="header-anchor">#</a> <strong>作为函数直接被调用</strong></h4> <p>这里我们说的函数“作为一个函数”被调用是为了区别于其他的调用方式：方法、构造函数和apply/call。如果一个函数没有作为方法、构造函数或者通过apply和call调用的话，我们就称之为作为函数被直接调用。</p> <p>通过()运算符调用一个函数，且被执行的函数表达式不是作为一个对象的属性存在时，就属于这种调用类型。（当执行的函数表达式是一个对象属性时，属于接下来将要讨论的方法调用类型）这里有一些简单的示例：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ninja</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token function">ninja</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　←<span class="token operator">--</span><span class="token operator">-</span>　函数定义作为函数被调用  

<span class="token keyword">var</span> <span class="token function-variable function">samurai</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token function">samurai</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　←<span class="token operator">--</span><span class="token operator">-</span><span class="token function">　函数表达式作为函数被调用</span> 
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>　　←<span class="token operator">--</span><span class="token operator">-</span>　会被立即调用的函数表达式，作为函数被调用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当以这种方式调用时，函数上下文（this关键字的值）<strong>有两种可能性：在非严格模式下，它将是全局上下文（window对象），而在严格模式下，它将是undefined</strong>。</p> <h4 id="作为方法被调用"><a href="#作为方法被调用" aria-hidden="true" class="header-anchor">#</a> 作为方法被调用</h4> <p><a href="/Frontend-Knowledge-Base/frontend/JavaScript/object.html#对象方法与this">详见对象方法与this</a></p> <p>当一个函数被赋值给一个对象的属性，并且通过对象属性引用的方式调用函数时，函数会作为对象的方法被调用。示例如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> ninja <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
ninja<span class="token punctuation">.</span><span class="token function-variable function">skulk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
ninja<span class="token punctuation">.</span><span class="token function">skulk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种情况下函数被称为方法，如果你有面向对象编程的经历，一定会联想到是否可以在方法内部通过this访问到对象主体。这种情况下同样适用。</p> <p><strong>当函数作为某个对象的方法被调用时，该对象会成为函数的上下文，并且在函数内部可以通过参数访问到</strong>。这也是JavaScript实现面向对象编程的主要方式之一。（构造函数是另外一种方式，我们很快就会提到）</p> <h4 id="作为构造函数被调用"><a href="#作为构造函数被调用" aria-hidden="true" class="header-anchor">#</a> 作为构造函数被调用</h4> <p>当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造函数里的 this 就指向返回的这个对象，见如下代码：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">MyClass</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'sven'</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">alert</span> <span class="token punctuation">(</span> obj<span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：sven </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对
象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">MyClass</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'sven'</span><span class="token punctuation">;</span> 
 <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token comment">// 显式地返回一个对象</span>
 name<span class="token punctuation">:</span> <span class="token string">'anne'</span> 
 <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">alert</span> <span class="token punctuation">(</span> obj<span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：anne</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="使用apply和call方法调用"><a href="#使用apply和call方法调用" aria-hidden="true" class="header-anchor">#</a> <strong>使用apply和call方法调用</strong></h4> <p>JavaScript为我们提供了一种调用函数的方式，从而可以显式地指定任何对象作为函数的上下文。我们可以使用每个函数上都存在的这两种方法来完成：apply和call。</p> <p>传入call 和 apply 方法的第一个参数都会被作为函数上下文，不同处在于后续的参数。apply方法只需要一个额外的参数，也就是一个包含参数值的数组；call方法则需要传入任意数量的参数值，这些参数将用作函数的实参.</p> <h4 id="解决上下文问题"><a href="#解决上下文问题" aria-hidden="true" class="header-anchor">#</a> 解决上下文问题</h4> <p>处理JavaScript函数上下文时可能遇到的一些问题。在回调函数中（例如事件处理器），函数上下文与预期不符，但可以使用call或apply方法绕过。还有另外两个选择：箭头函数和bind方法，在一些情况下可以更优雅地实现相同的效果。</p> <h5 id="使用箭头函数绕过函数上下文"><a href="#使用箭头函数绕过函数上下文" aria-hidden="true" class="header-anchor">#</a> <strong>使用箭头函数绕过函数上下文</strong></h5> <p>箭头函数不会创建自己的<code>this,它只会从自己的作用域链的上一层继承this</code>。this值是在箭头函数创建时确定的。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
test<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 立即调用箭头函数</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>箭头函数需要注意的：箭头函数没有 this 绑定，意味着<strong>箭头函数内部的 this 值只能通过查找作用域链来确定</strong>。
如果箭头函数被包含在一个非箭头函数内，那么 this 值就会与该函数的相等；否则，this 值就会是全局对象（在浏览器中是 window ，在 nodejs 中是 global ）。在全局代码中定义对象字面量，在字面量中定义箭头函数，那么箭头函数内的this指向全局window对象</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
test<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// 箭头函数</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// windows</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>Arrow functions VS bind</strong></p> <p>箭头函数 <code>=&gt;</code> 和正常函数通过 <code>.bind(this)</code> 调用有一个微妙的区别：</p> <ul><li><code>.bind(this)</code> 创建该函数的 “绑定版本”。</li> <li>箭头函数 <code>=&gt;</code> 不会创建任何绑定。该函数根本没有 <code>this</code>。在外部上下文中，<code>this</code> 的查找与普通变量搜索完全相同。</li></ul> <h5 id="使用bind方法"><a href="#使用bind方法" aria-hidden="true" class="header-anchor">#</a> <strong>使用bind方法</strong></h5> <p>所有函数均可访问bind方法，可以创建并返回一个新函数，并绑定在传入的对象上。**不管如何调用该函数，this均被设置为传入对象本身。**被绑定的函数与原始函数行为一致，函数体一致。</p> <p>调用bind方法不会修改原始函数，而是创建了一个全新的函数。</p> <h4 id="小结"><a href="#小结" aria-hidden="true" class="header-anchor">#</a> <strong>小结</strong></h4> <ul><li>当调用函数时，除了传入在函数定义中显式声明的参数之外，同时还传入两个隐式参数：arguments与this。
<ul><li>arguments参数是传入函数的所有参数的集合。具有length属性，表示传入参数的个数，通过arguments参数还可获取那些与函数形参不匹配的参数。在非严格模式下，arguments对象是函数参数的别名，修改arguments对象会修改函数实参，可以通过严格模式避免修改函数实参。</li> <li>this表示函数上下文，即与函数调用相关联的对象。函数的定义方式和调用方式决定了this的取值。</li></ul></li> <li>函数的调用方式有4种。
<ul><li>作为函数调用：skulk()。</li> <li>作为方法调用：ninja.skulk()。</li> <li>作为构造函数调用：new Ninja()。</li> <li>通过apply与call方法调用：skulk.apply(ninja)或skulk.call(ninja)。</li></ul></li> <li>函数的调用方式影响this的取值。
<ul><li>如果作为函数调用，在非严格模式下，this指向全局window对象；在严格模式下，this指向undefined。</li> <li>作为方法调用，this通常指向调用的对。</li> <li>作为构造函数调用，this指向新创建的对象。</li> <li>通过call或apply调用，this指向call或apply的第一个参数。</li></ul></li> <li>箭头函数没有单独的this值，this在箭头函数创建时确定。</li> <li>所有函数均可使用bind方法，创建新函数，并绑定到bind方法传入的参数上。被绑定的函数与原始函数具有一致的行为。</li></ul> <p>闭包、作用域</p> <h2 id="深浅拷贝"><a href="#深浅拷贝" aria-hidden="true" class="header-anchor">#</a> 深浅拷贝</h2> <p>对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个情况。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
  age: 1
}
let b = a
a.age = 2
console.log(b.age) // 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="浅拷贝"><a href="#浅拷贝" aria-hidden="true" class="header-anchor">#</a> 浅拷贝</h3> <p>首先可以通过 <code>Object.assign</code> 。<code>Object.assign</code> 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
  age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>另外我们还可以通过展开运算符 <code>...</code> 来实现浅拷贝</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
  age: 1
}
let b = { ...a }
a.age = 2
console.log(b.age) // 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
  age: 1,
  jobs: {
    first: 'FE'
  }
}
let b = { ...a }
a.jobs.first = 'native'
console.log(b.jobs.first) // native
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。</p> <h3 id="深拷贝"><a href="#深拷贝" aria-hidden="true" class="header-anchor">#</a> 深拷贝</h3> <p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
  age: 1,
  jobs: {
    first: 'FE'
  }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>但是该方法也是有局限性的：</p> <ul><li>会忽略 <code>undefined</code></li> <li>会忽略 <code>symbol</code></li> <li>不能序列化函数</li> <li>不能解决循环引用的对象</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>let obj = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  },
}
obj.c = obj.b
obj.e = obj.a
obj.b.c = obj.c
obj.b.d = obj.b
obj.b.e = obj.b.c
let newObj = JSON.parse(JSON.stringify(obj))
console.log(newObj)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>如果你有这么一个循环引用对象，你会发现并不能通过该方法实现深拷贝</p> <p>在遇到函数、 <code>undefined</code> 或者 <code>symbol</code> 的时候，该对象也不能正常的序列化</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
  age: undefined,
  sex: Symbol('male'),
  jobs: function() {},
  name: 'yck'
}
let b = JSON.parse(JSON.stringify(a))
console.log(b) // {name: &quot;yck&quot;}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>你会发现在上述情况中，该方法会忽略掉函数和 <code>undefined</code> 。</p> <p>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题。</p> <p>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 <code>MessageChannel</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function structuralClone(obj) {
  return new Promise(resolve =&gt; {
    const { port1, port2 } = new MessageChannel()
    port2.onmessage = ev =&gt; resolve(ev.data)
    port1.postMessage(obj)
  })
}

var obj = {
  a: 1,
  b: {
    c: 2
  }
}

obj.b.d = obj.b

// 注意该方法是异步的
// 可以处理 undefined 和循环引用对象
const test = async () =&gt; {
  const clone = await structuralClone(obj)
  console.log(clone)
}
test()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>当然你可能想自己来实现一个深拷贝，但是其实实现一个深拷贝是很困难的，需要我们考虑好多种边界情况，比如原型链如何处理、DOM 如何处理等等，所以这里我们实现的深拷贝只是简易版，并且我其实更推荐使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Flodash.com%2Fdocs%23cloneDeep" target="_blank" rel="noopener noreferrer">lodash 的深拷贝函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function deepClone(obj) {
  function isObject(o) {
    return (typeof o === 'object' || typeof o === 'function') &amp;&amp; o !== null
  }

  if (!isObject(obj)) {
    throw new Error('非对象')
  }

  let isArray = Array.isArray(obj)
  let newObj = isArray ? [...obj] : { ...obj }
  Reflect.ownKeys(newObj).forEach(key =&gt; {
    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
  })

  return newObj
}

let obj = {
  a: [1, 2, 3],
  b: {
    c: 2,
    d: 3
  }
}
let newObj = deepClone(obj)
newObj.b.c = 1
console.log(obj.b.c) // 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="开发者工具devtools"><a href="#开发者工具devtools" aria-hidden="true" class="header-anchor">#</a> 开发者工具devtools</h2> <h2 id="编程思想"><a href="#编程思想" aria-hidden="true" class="header-anchor">#</a> 编程思想</h2> <p>控制反转</p> <p>中间件</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/jinjun1994/Frontend-Knowledge-Base/edit/master/frontend/JavaScript/README.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">6/8/2020, 11:34:51 AM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/Frontend-Knowledge-Base/frontend/JavaScript/array.html">
          数组
        </a>
        →
      </span></p></div> </main> <div class="page"><section class="page-edit"><h3 style="display:;"><a href="javascript:;"></a>
      评 论：
    </h3> <div id="vcomments"></div></section></div></div><div class="global-ui"><!----></div></div>
    <script src="/Frontend-Knowledge-Base/assets/js/app.be30c89b.js" defer></script><script src="/Frontend-Knowledge-Base/assets/js/4.d5d74749.js" defer></script><script src="/Frontend-Knowledge-Base/assets/js/40.ee0861ee.js" defer></script><script src="/Frontend-Knowledge-Base/assets/js/9.1a9c75bd.js" defer></script>
  </body>
</html>
