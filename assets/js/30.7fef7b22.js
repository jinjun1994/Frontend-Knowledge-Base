(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{90:function(t,e,a){"use strict";a.r(e);var r=a(3),v=Object(r.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"代码回滚：reset、checkout、revert-的选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码回滚：reset、checkout、revert-的选择","aria-hidden":"true"}},[t._v("#")]),t._v(" 代码回滚：Reset、Checkout、Revert 的选择")]),t._v(" "),a("blockquote",[a("p",[t._v("BY 童仲毅（"),a("a",{attrs:{href:"https://github.com/geeeeeeeeek/git-recipes/",target:"_blank",rel:"noopener noreferrer"}},[t._v("geeeeeeeeek@github"),a("OutboundLink")],1),t._v("）")]),t._v(" "),a("p",[t._v("这是一篇在"),a("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting",target:"_blank",rel:"noopener noreferrer"}},[t._v("原文（BY atlassian）"),a("OutboundLink")],1),t._v("基础上演绎的译文。除非另行注明，页面上所有内容采用知识共享-署名（"),a("a",{attrs:{href:"http://creativecommons.org/licenses/by/2.5/au/deed.zh",target:"_blank",rel:"noopener noreferrer"}},[t._v("CC BY 2.5 AU"),a("OutboundLink")],1),t._v("）协议共享。")])]),t._v(" "),a("p",[a("code",[t._v("git reset")]),t._v("、"),a("code",[t._v("git checkout")]),t._v(" 和 "),a("code",[t._v("git revert")]),t._v(" 是你的 Git 工具箱中最有用的一些命令。它们都用来撤销代码仓库中的某些更改，而前两个命令不仅可以作用于提交，还可以作用于特定文件。")]),t._v(" "),a("p",[t._v("因为它们非常相似，所以我们经常会搞混，不知道什么场景下该用哪个命令。在这篇文章中，我们会比较 "),a("code",[t._v("git reset")]),t._v("、"),a("code",[t._v("git checkout")]),t._v(" 和 "),a("code",[t._v("git revert")]),t._v(" 最常见的用法。希望你在看完后能游刃有余地使用这些命令来管理你的仓库。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://wac-cdn.atlassian.com/dam/jcr:0c5257d5-ff01-4014-af12-faf2aec53cc3/01.svg",alt:"Git repo的主要组成"}})]),t._v(" "),a("p",[t._v("Git 仓库有三个主要组成——工作目录，缓存区和提交历史。这张图有助于理解每个命令到底产生了哪些影响。当你阅读的时候，牢记这张图。")]),t._v(" "),a("h2",{attrs:{id:"提交层面的操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提交层面的操作","aria-hidden":"true"}},[t._v("#")]),t._v(" 提交层面的操作")]),t._v(" "),a("p",[t._v("你传给 "),a("code",[t._v("git reset")]),t._v(" 和 "),a("code",[t._v("git checkout")]),t._v(" 的参数决定了它们的作用域。如果你没有包含文件路径，这些操作对所有提交生效。我们这一节要探讨的就是提交层面的操作。注意，"),a("code",[t._v("git revert")]),t._v(" 没有文件层面的操作。")]),t._v(" "),a("h3",{attrs:{id:"reset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reset","aria-hidden":"true"}},[t._v("#")]),t._v(" Reset")]),t._v(" "),a("p",[t._v("在提交层面上，reset 将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交。比如，下面这两条命令让 hotfix 分支向后回退了两个提交。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git checkout hotfix\ngit reset HEAD~2\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("hotfix 分支末端的两个提交现在变成了悬挂提交。也就是说，下次 Git 执行垃圾回收的时候，这两个提交会被删除。换句话说，如果你想扔掉这两个提交，你可以这么做。reset 操作如下图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://wac-cdn.atlassian.com/dam/jcr:4c7d368e-6e40-4f82-a315-1ed11316cf8b/02-updated.png",alt:"把hotfix分支reset到HEAD~2"}})]),t._v(" "),a("p",[t._v("如果你的更改还没有共享给别人，"),a("code",[t._v("git reset")]),t._v(" 是撤销这些更改的简单方法。当你开发一个功能的时候发现「糟糕，我做了什么？我应该重新来过！」时，reset 就像是 go-to 命令一样。")]),t._v(" "),a("p",[t._v("除了在当前分支上操作，你还可以通过传入这些标记来修改你的缓存区或工作目录：")]),t._v(" "),a("ul",[a("li",[t._v("--soft – 缓存区和工作目录都不会被改变")]),t._v(" "),a("li",[t._v("--mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响")]),t._v(" "),a("li",[t._v("--hard – 缓存区和工作目录都同步到你指定的提交")])]),t._v(" "),a("p",[t._v("把这些标记想成定义 "),a("code",[t._v("git reset")]),t._v(" 操作的作用域就容易理解多了。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://www.atlassian.com/git/images/tutorials/advanced/resetting-checking-out-and-reverting/03.svg",alt:"git rese的定义域"}})]),t._v(" "),a("p",[t._v("这些标记往往和 HEAD 作为参数一起使用。比如，"),a("code",[t._v("git reset --mixed HEAD")]),t._v(" 将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中。另一方面，如果你想完全舍弃你没有提交的改动，你可以使用 "),a("code",[t._v("git reset --hard HEAD")]),t._v("。这是 "),a("code",[t._v("git reset")]),t._v(" 最常用的两种用法。")]),t._v(" "),a("p",[t._v("当你传入 HEAD 以外的其他提交的时候要格外小心，因为 reset 操作会重写当前分支的历史。正如 rebase 黄金法则所说的，在公共分支上这样做可能会引起严重的后果。")]),t._v(" "),a("h3",{attrs:{id:"checkout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checkout","aria-hidden":"true"}},[t._v("#")]),t._v(" Checkout")]),t._v(" "),a("p",[t._v("你应该已经非常熟悉提交层面的 "),a("code",[t._v("git checkout")]),t._v("。当传入分支名时，可以切换到那个分支。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git checkout hotfix\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("上面这个命令做的不过是将HEAD移到一个新的分支，然后更新工作目录。因为这可能会覆盖本地的修改，Git 强制你提交或者缓存工作目录中的所有更改，不然在 checkout 的时候这些更改都会丢失。和 "),a("code",[t._v("git reset")]),t._v(" 不一样的是，"),a("code",[t._v("git checkout")]),t._v(" 没有移动这些分支。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://wac-cdn.atlassian.com/dam/jcr:607f1b83-ee7d-494a-b7e2-338d810059fb/04-updated.png",alt:"将 HEAD 从 master 移到 hotfix"}})]),t._v(" "),a("p",[t._v("除了分支之外，你还可以传入提交的引用来 checkout 到任意的提交。这和 checkout 到另一个分支是完全一样的：把 HEAD 移动到特定的提交。比如，下面这个命令会 checkout 到当前提交的祖父提交。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git checkout HEAD~2\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://wac-cdn.atlassian.com/dam/jcr:3034be0a-fc7b-4c64-b9cd-3ebc8abf3833/05.svg",alt:"将 HEAD 移动到任意 commit"}})]),t._v(" "),a("p",[t._v("这对于快速查看项目旧版本来说非常有用。但如果你当前的 HEAD 没有任何分支引用，那么这会造成 HEAD 分离。这是非常危险的，如果你接着添加新的提交，然后切换到别的分支之后就没办法回到之前添加的这些提交。因此，在为分离的 HEAD 添加新的提交的时候你应该创建一个新的分支。")]),t._v(" "),a("h3",{attrs:{id:"revert"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#revert","aria-hidden":"true"}},[t._v("#")]),t._v(" Revert")]),t._v(" "),a("p",[t._v("Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git checkout hotfix\ngit revert HEAD~2\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("如下图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://wac-cdn.atlassian.com/dam/jcr:73d36b14-72a7-4e96-a5bf-b86629d2deeb/06.svg",alt:"revert到倒数第二个commit"}})]),t._v(" "),a("p",[t._v("相比 "),a("code",[t._v("git reset")]),t._v("，它不会改变现在的提交历史。因此，"),a("code",[t._v("git revert")]),t._v(" 可以用在公共分支上，"),a("code",[t._v("git reset")]),t._v(" 应该用在私有分支上。")]),t._v(" "),a("p",[t._v("你也可以把 "),a("code",[t._v("git revert")]),t._v(" 当作撤销已经提交的更改，而 "),a("code",[t._v("git reset HEAD")]),t._v(" 用来撤销没有提交的更改。")]),t._v(" "),a("p",[t._v("就像 "),a("code",[t._v("git checkout")]),t._v(" 一样，"),a("code",[t._v("git revert")]),t._v(" 也有可能会重写文件。所以，Git 会在你执行 revert 之前要求你提交或者缓存你工作目录中的更改。")]),t._v(" "),a("h2",{attrs:{id:"文件层面的操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件层面的操作","aria-hidden":"true"}},[t._v("#")]),t._v(" 文件层面的操作")]),t._v(" "),a("p",[a("code",[t._v("git reset")]),t._v(" 和 "),a("code",[t._v("git checkout")]),t._v(" 命令也接受文件路径作为参数。这时它的行为就大为不同了。它不会作用于整份提交，参数将它限制于特定文件。")]),t._v(" "),a("h3",{attrs:{id:"reset-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reset-2","aria-hidden":"true"}},[t._v("#")]),t._v(" Reset")]),t._v(" "),a("p",[t._v("当检测到文件路径时，"),a("code",[t._v("git reset")]),t._v(" 将缓存区同步到你指定的那个提交。比如，下面这个命令会将倒数第二个提交中的 "),a("code",[t._v("foo.py")]),t._v(" 加入到缓存区中，供下一个提交使用。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git reset HEAD~2 foo.py\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("和提交层面的 "),a("code",[t._v("git reset")]),t._v(" 一样，通常我们使用HEAD而不是某个特定的提交。运行 "),a("code",[t._v("git reset HEAD foo.py")]),t._v(" 会将当前的 "),a("code",[t._v("foo.py")]),t._v(" 从缓存区中移除出去，而不会影响工作目录中对 "),a("code",[t._v("foo.py")]),t._v(" 的更改。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://wac-cdn.atlassian.com/dam/jcr:1a010f5a-c90d-49ee-a0e6-31054433e2d4/07.svg",alt:"将一个文件从 commit 历史中移动到 stage 缓存中"}})]),t._v(" "),a("p",[a("code",[t._v("--soft")]),t._v("、"),a("code",[t._v("--mixed")]),t._v(" 和 "),a("code",[t._v("--hard")]),t._v(" 对文件层面的 "),a("code",[t._v("git reset")]),t._v(" 毫无作用，因为缓存区中的文件一定会变化，而工作目录中的文件一定不变。")]),t._v(" "),a("h3",{attrs:{id:"checkout-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checkout-2","aria-hidden":"true"}},[t._v("#")]),t._v(" Checkout")]),t._v(" "),a("p",[t._v("Checkout 一个文件和带文件路径 "),a("code",[t._v("git reset")]),t._v(" 非常像，除了它更改的是工作目录而不是缓存区。不像提交层面的 checkout 命令，它不会移动  HEAD引用，也就是你不会切换到别的分支上去。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://wac-cdn.atlassian.com/dam/jcr:cc252fc0-fc76-4740-8458-9c0d7af94bca/08.svg",alt:"将文件从提交历史移动到工作目录中"}})]),t._v(" "),a("p",[t._v("比如，下面这个命令将工作目录中的 "),a("code",[t._v("foo.py")]),t._v(" 同步到了倒数第二个提交中的 "),a("code",[t._v("foo.py")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git checkout HEAD~2 foo.py\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("和提交层面相同的是，它可以用来检查项目的旧版本，但作用域被限制到了特定文件。")]),t._v(" "),a("p",[t._v("如果你缓存并且提交了 checkout 的文件，它具备将某个文件回撤到之前版本的效果。注意它撤销了这个文件后面所有的更改，而 "),a("code",[t._v("git revert")]),t._v(" 命令只撤销某个特定提交的更改。")]),t._v(" "),a("p",[t._v("和 "),a("code",[t._v("git reset")]),t._v(" 一样，这个命令通常和 HEAD 一起使用。比如 "),a("code",[t._v("git checkout HEAD foo.py")]),t._v(" 等同于舍弃 "),a("code",[t._v("foo.py")]),t._v(" 没有缓存的更改。这个行为和 "),a("code",[t._v("git reset HEAD --hard")]),t._v(" 很像，但只影响特定文件。")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("你现在已经掌握了 Git 仓库中撤销更改的所有工具。"),a("code",[t._v("git reset")]),t._v("、"),a("code",[t._v("git checkout")]),t._v(" 和 "),a("code",[t._v("git revert")]),t._v(" 命令比较容易混淆，但当你想起它们对工作目录、缓存区和提交历史的不同影响，就会容易判断现在应该用哪个命令。")]),t._v(" "),a("p",[t._v("下面这个表格总结了这些命令最常用的使用场景。记得经常对照这个表格，因为你使用 Git 时一定会经常用到。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("命令")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("作用域")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("常用情景")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("git reset")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("提交层面")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("在私有分支上舍弃一些没有提交的更改")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("git reset")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("文件层面")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("将文件从缓存区中移除")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("git checkout")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("提交层面")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("切换分支或查看旧版本")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("git checkout")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("文件层面")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("舍弃工作目录中的更改")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("git revert")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("提交层面")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("在公共分支上回滚更改")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("git revert")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("文件层面")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("（然而并没有）")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("这篇文章是"),a("a",{attrs:{href:"https://github.com/geeeeeeeeek/git-recipes/",target:"_blank",rel:"noopener noreferrer"}},[a("strong",[t._v("「git-recipes」")]),a("OutboundLink")],1),t._v("的一部分，点击 "),a("a",{attrs:{href:"https://github.com/geeeeeeeeek/git-recipes/wiki/",target:"_blank",rel:"noopener noreferrer"}},[a("strong",[t._v("目录")]),a("OutboundLink")],1),t._v(" 查看所有章节。")]),t._v(" "),a("p",[t._v("如果你觉得文章对你有帮助，欢迎点击右上角的 "),a("strong",[t._v("Star")]),t._v(" 🌟 或 "),a("strong",[t._v("Fork")]),t._v(" 🍴。")]),t._v(" "),a("p",[t._v("如果你发现了错误，或是想要加入协作，请参阅 "),a("a",{attrs:{href:"https://github.com/geeeeeeeeek/git-recipes/issues/1",target:"_blank",rel:"noopener noreferrer"}},[t._v("Wiki 协作说明"),a("OutboundLink")],1),t._v("。")])])])},[],!1,null,null,null);e.default=v.exports}}]);